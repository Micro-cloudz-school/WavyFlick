<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>WavyFlick</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { display: block; }
    button { position: absolute; z-index: 10; }
    h1 { position: absolute; top: 40px; color: white; font-family: monospace; }
  </style>
</head>
<body>

<button onclick="connectSerial()">Connect Serial</button>
<h1 id="chkn">No values yet</h1>

<script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>

<script>
/* ================= SERIAL STUFF ================= */
let port;
let reader;
let roll = 0;
let pitch = 0;
let serialBuffer = "";

async function connectSerial() {
  try {
    port = await navigator.serial.requestPort();
    await port.open({ baudRate: 9600 });

    const decoder = new TextDecoderStream();
    port.readable.pipeTo(decoder.writable);
    reader = decoder.readable.getReader();

    readSerialLoop();
  } catch (err) {
    console.error("Serial failed:", err);
  }
}

async function readSerialLoop() {
  while (true) {
    const { value, done } = await reader.read();
    if (done) break;

    serialBuffer += value;
    let lines = serialBuffer.split("\n");
    serialBuffer = lines.pop();

    for (let line of lines) {
      const parts = line.trim().split(",");
      if (parts.length === 2) {
        const r = parseFloat(parts[0]);
        const p = parseFloat(parts[1]);

        if (!isNaN(r) && !isNaN(p)) {
          roll = r;
          pitch = p;

          document.getElementById("chkn").innerText =
            `Roll: ${roll.toFixed(2)} | Pitch: ${pitch.toFixed(2)}`;
        }
      }
    }
  }
}

/* ================= THREE.JS STUFF ================= */
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* ===== LIGHTS ===== */
const light = new THREE.DirectionalLight(0xffffff, 3);
light.position.set(5, 5, 5);
scene.add(light);

scene.add(new THREE.AmbientLight(0x404040, 1));

/* ===== TORUS KNOT ===== */
  
const knotGeo = new THREE.TorusKnotGeometry(1, 0.3, 100, 16, 3, 5);
const knotMat = new THREE.MeshStandardMaterial({
  color: 0x97effc,
  emissive: 0xffffff,
  emissiveIntensity: 0.1
});
const knot = new THREE.Mesh(knotGeo, knotMat);
knot.position.x = -40;
scene.add(knot);

/* ===== TEXTURED SPHERE ===== */
const loader = new THREE.TextureLoader();
const sphereTexture = loader.load("https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcR3P_bqAOf8yeYDXvPk6yeMzueBJAv3uRuslw&s");
  
  sphereTexture.repeat.set(2, 2);   // BIG CENA
  sphereTexture.repeat.set(1.5, 1.5); // zoom IN

const sphereGeo = new THREE.SphereGeometry(1, 32, 32);
const sphereMat = new THREE.MeshStandardMaterial({
  map: sphereTexture
});
const sphere = new THREE.Mesh(sphereGeo, sphereMat);
sphere.position.y = 3;
scene.add(sphere);
  const bodysphereGeo = new THREE.SphereGeometry(1.6, 32, 32);
const sphereMat2 = new THREE.MeshStandardMaterial({
  map: sphereTexture
});
  const sphere2 = new THREE.Mesh(bodysphereGeo, sphereMat2);
sphere2.position.y = 0;
scene.add(sphere2);

/* ===== ANIMATE ===== */
function animate() {
  requestAnimationFrame(animate);

  const t = Date.now() * 0.001;
  knot.material.color.setHSL((Math.sin(t) + 1) / 2, 0.6, 0.5);

  // Sensor control
  knot.rotation.x = roll * 0.05;
  knot.rotation.z = pitch * 0.05;

  sphere.rotation.x = roll * 0.05;
  sphere.rotation.z = pitch * 0.05;

  renderer.render(scene, camera);
}
animate();

/* ===== RESIZE ===== */
window.addEventListener("resize", () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
